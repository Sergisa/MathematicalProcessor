#Математический процессор
![Коммит](https://img.shields.io/badge/Информативный%20коммит-NO-critical "Неинформативные коммиты")
![Branch-less](https://img.shields.io/badge/Ветки-NO-critical "No branches")

Здесь создан класс выполняющий математические операции.
## Этап первый

---
Нам необходимо написать механизм, который сможет выполнять простейшие математические операции. 
- Факториал (factorial)
- Синус (sin)
- Косинус (cos)
- Экспонента (exp)
- Среднее арифметическое (mean)
- Степень (pow)

Давайте для начала вспомним формулы этих операций  
![факториал](https://latex.codecogs.com/svg.latex?x!=1\cdot2\cdot3\cdot...\cdot{x}=\prod_{i=1}^{x}i\\ "Факториал")  
![Cреднее арифметическое](https://latex.codecogs.com/svg.latex?\mu(X)=\frac{x_1+x_2+x_3+...+x_n}{n}=\sum_{i=0}^{n}\frac{x_i}{n}=\frac{\sum_{i=0}^{n}x_i}{n}\\ "Среднее арифметическое")  
![Cтепень](https://latex.codecogs.com/svg.latex?x^n=x\cdot{x}\cdot{x}\cdot...=\prod_{i=1}^{n}x\\ "Степень")    
Остальные процедуры можно легко реализовать через Класс java.lang.Math в Java.  
> **Помните что тригонометрические функции работают с радианной мерой угла, а не градусной!!!**

#### Куда положить функции
Вы наверное уже поместили эти функции в класс Main и нарекли их статическими. А теперь уберите их оттуда и положите в отдельный класс. Потому-то задача математических вычислений должна выполняться не основной программой, а модулем/классом нашей программы. Это что-то вроде правила этикета: раскладывать функции в свои классы. От того что вы переместите их в отдельный класс абсолютно ничего не изменится - программа будет ровно так же выполнятся, как и до этого, но теперь строка будет выглядеть намного адекватнее и будет больше напоминать связанное предложение.  
Сравните сами: `Main.sin()` - `Программа считает синус` и что это, простите за программа, самым верхним действием (метадействием) которой является посчитать синус? `Mathematics.sin()` - `Модуль математики считает синус`. Теперь всё логично: программа обращается к своему подмодулю для выполнения необходимого действия.

#### static или public
Теперь другой вопрос: а использовать наши функции мы будем в динамическом или статическом контексте? Что бы ответить на этот порос необходимо выяснить, а будет ли зависеть принцип исполнения этой функции от того в каком классе мы её вызовем? Иначе говоря, будут ли чем то отличаться контексты вызова? Например, при использовании математических алгоритмов в классе номер 1 мы хотим использовать функционал в режиме повышенной точности чисел, а в некотором другом классе номер 2 нам достаточно округления до сотых. Для такого применения нам необходимо будет объявлять функции в классе в динамическом контексте и в последствии создавать объект класса Mathematics, передавая в конструктор, например, числовое значение требуемой точности.

#### private или public
Теперь давайте выясним приватные должны быть функции или публичные. Здесь всё просто! Приватные функции доступны для использования только в коде самого класса, а публичные можно использовать в любом другом классе.

Для того что бы это был модуль доступен из любой точки программы нам нужно его поместить в класс Mathematics например.
```java
Mathematics myStrictMath = new Mathematics(precissionValue);
myStrictMath.sin(3.14 / 2)
```
Теперь нам доступны все публичные функции класса Mathematics, но плюс ко всему именно этот объект (*myStrictMath*) помнит конкретный, переданный ему, показатель точности вычислений.
А пример статического контекста это просто исполнение функции в виде `Mathematics.cos(3.14 / 2)`

#### Запуск
Теперь осталось описанные алгоритмы проверить на работоспособность. Когда мы разрабатываем некоторый модуль какой-то программы крайне нежелательно проверять его работоспособность, вставляя вызов методов и функций класса куда-либо в программу: в метод **main** например или в любой другой уже существующий класс работающей программы. Потом, нам всё равно придется искать по всей программе тестовые вызовы и убирать их оттуда.  
Для тестирования какого-либо функционала лучше всего использовать тесты.  
Тесты это мини-программы написанные на данном языке. В контексте Java ООП тесты представляют собой void функции в некотором классе, например `MathematicTests`, которые можно запускать либо по-отдельности, либо все вместе (все тесты в классе). В классе один тест-функция должен покрывать один тестируемый метод и полностью проверять его работоспособность. В нашем случаем нам необходимо создать шесть тестов под каждый реализуемый математический функционал.  

Внутри каждого теста мы напишем простую строку, которая проверит факт того что наша функция факториала возвращает правильное, указанное нами значение: `Assertions.assertEquals(6, Mathematics.factorial(3));`. Однако суть тестов заключается в том, что проверяя функцию на работоспособность иы должны так же проверить её устойчивость к исключительным ситуациям. А в случае факториала есть одна исключительная ситуация - это факториал от нуля. Значит наши тесты должны теперь выглядеть следующим образом:
```java
Assertions.assertEquals(1, Mathematics.factorial(0));
Assertions.assertEquals(6, Mathematics.factorial(3));
```
При тестировании тригонометрических функций мы не всегда сможем **в точности** сравнивать полученный ответ с необходимым. Например, из-за особенностей работы java синус 90 градусов будет равен не 1, а 0.(9)
Что бы это учитывать нам нужно указать погрешность сравнения
```java
Assertions.assertEquals(6, Mathematics.sin(3.14 / 2), 0.01);
```

### Доп задача
> **А что если попробовать написать функцию факториала и степени в одну строчку?**  

Для этого нам понадобится вспомнить всего лишь две конструкции программирования:
- Рекурсия
- Однострочная сокращенная запись IF

## Этап второй

---
Прошло некоторое время, и наша воображаемая программа обросла новыми модулями и какими-то еще изменениями и пора поменять принцип действия тригонометрических операций. 
Мы написали с вами функции, но принцип работы некоторых из них ссылается на уже реализованный алгоритм в классе Math (синус, косинус, экспонента). Теперь давайте перестроим наши алгоритмы таким способом, чтобы эти три действия сводились к арифметическим действиям сложения, умножения и т.д.
### Мат.теория
Теоретически любую математическую функцию можно разложить в бесконечный [Ряд Тейлора](http://cyclowiki.org/wiki/%D0%A0%D1%8F%D0%B4_%D0%A2%D0%B5%D0%B9%D0%BB%D0%BE%D1%80%D0%B0). Это ряд, который высчитывается как сумма значений производных данной функции в некоторой точке. Частым случаем этих рядов являются [Ряды Маклорена](http://cyclowiki.org/wiki/%D0%A0%D1%8F%D0%B4_%D0%9C%D0%B0%D0%BA%D0%BB%D0%BE%D1%80%D0%B5%D0%BD%D0%B0). Согласно этой теории наши три функции можно описать в циклическом виде:
![экспонента](https://latex.codecogs.com/svg.latex?e^x%20=%20\sum_{n=0}^{N}{\frac{x^n}{n!}}\\)  
![синус](https://latex.codecogs.com/svg.latex?sin(x)=\sum_{n=0}^{N}{(-1)^n\frac{x^{2n+1}}{(2n+1)!}}\\)  
![косинус](https://latex.codecogs.com/svg.latex?\cos(x)=\sum_{n=0}^{N}{\frac{x^{2n}}{(2n)!}}\\)

### Применение
Давайте теперь перепишем наши функции. Но для начала необходимо определиться с тем сколько слагаемых ряда мы будем использовать. Пусть будет ***17***  
Функция косинуса теперь придёт к виду:
```java
public static double cos(double x){
    double sum = 0;
    for (int n = 0; n <= 17; n++) {
        sum += (power(-1, n) * power(x, 2 * n)) / (factorial(2 * n));
    }
    return sum;
}
```
Теперь, что бы протестировать написанный функционал, нам просто остаётся запустить пакет тестов ещё раз. Это намного удобнее чем снова засорять нашу программу вызовами `System.out.println(Mathematics.cos(3.14 / 2))` и впоследствии убирать их оттуда.

> А почему собственно мы выбрали 17 циклов? Может надо больше или меньше? Попробуйте выяснить как влияет количество выбранных итераций на результат.

У рядов Маклорена есть некоторая особенность. Особенность заключается в том что разложение с одним количеством итераций годится не для всех расчётов. Наши 17 итераций хорошо себя показывают лишь при подсчёте определенных значений, при расчёте синуса от других значений мы будем получать результаты с разной, а порой и критической степенью грубости. Но тесты у нас же ведь проходят и тестирование не выявляет неисправностей. Значит наши тесты написаны плохо и не покрывают проверку исключительных ситуаций. Давайте их расширим.
```java
Assertions.assertEquals(0, Mathematics.sin(Math.toRadians(0)), DELTA, "sin(0)");
Assertions.assertEquals((Math.sqrt(6) - Math.sqrt(2)) / 4, Mathematics.sin(Math.toRadians(15)), DELTA, "sin(15)");
Assertions.assertEquals(0.5, Mathematics.sin(Math.toRadians(30)), DELTA, "sin(30)");
Assertions.assertEquals(Math.sqrt(2) / 2, Mathematics.sin(Math.toRadians(45)), DELTA, "sin(45)");
Assertions.assertEquals(Math.sqrt(3) / 2, Mathematics.sin(Math.toRadians(60)), DELTA, "sin(60)");
Assertions.assertEquals(1, Mathematics.sin(Math.toRadians(90)), DELTA, "sin(90)");
Assertions.assertEquals(Math.sqrt(3) / 2, Mathematics.sin(Math.toRadians(90 + 30)), DELTA, "sin(120)");
Assertions.assertEquals(Math.sqrt(2) / 2, Mathematics.sin(Math.toRadians(90 + 45)), DELTA, "sin(135)");
Assertions.assertEquals(0.5, Mathematics.sin(Math.toRadians(90 + 60)), DELTA, "sin(150)");
Assertions.assertEquals(0, Mathematics.sin(Math.toRadians(180)), DELTA, "sin(180)");
```
Теперь наши тесты никогда не пройдут успешно. И это хорошо, так как теперь мы благодаря тестам мы явно видим что реализация выбранного нами математического подхода никогда не даёт качественных вычислений с указанной точностью.


## Этап третий

---
Теперь давайте попробуем научить программу понимать и считать формулы. Наша задача дополнить программу таким образом, чтобы программа работала с формулой, а не с циклом который мы сами описали отталкиваясь от формулы. Иначе говоря давайте опишем функцию имеющую возможность работать с конкретной формулой.  
Нам нужно что-то подобное: `Посчитай сигму от xi/i для всех i от еденицы до длинны массива X`

То есть нам мысленно нужно разбить формулу на составляющие:
- **Сигма** как итерационный процесс с тремя параметрами: начальное значение, конечное значение и :
  - **Итерируемая функция** с одним параметром, как минимум - счетчиком итерации *i*

Лучше всего использовать для такой задачи интерфейсы. Интерфейсом мы будем описывать действие которое заключено под знак математической суммы.

Давайте прикинем сигнатуры функций.
```java
private static double sigma(IterableExpression expr, int iterations, int iterationStart) {
    double sum = 0;
    for (int n = iterationStart; n < iterations; n++) {
        sum += expr.execute(n);
    }
    return sum;
}
```