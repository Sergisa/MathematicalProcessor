#Математический процессор
![Коммит](https://img.shields.io/badge/Информативный%20коммит-NO-critical "Неинформативные коммиты")
![Branch-less](https://img.shields.io/badge/Ветки-NO-critical "No branches")

Здесь создан класс выполняющий математические операции.
## Этап первый
Нам необходимо написать механизм, который сможет выполнять простейшие математические операции. 
- Факториал (factorial)
- Синус (sin)
- Косинус (cos)
- Экспонента (exp)
- Среднее арифметическое (mean)
- Степень (pow)

Давайте для начала вспомним формулы этих операций  
![факториал](https://latex.codecogs.com/svg.latex?x!=1\cdot2\cdot3\cdot...\cdot{x}=\prod_{i=1}^{x}i\\ "Факториал")  
![Cреднее арифметическое](https://latex.codecogs.com/svg.latex?\mu(X)=\frac{x_1+x_2+x_3+...+x_n}{n}=\sum_{i=0}^{n}\frac{x_i}{n}=\frac{\sum_{i=0}^{n}x_i}{n}\\ "Среднее арифметическое")  
![Cтепень](https://latex.codecogs.com/svg.latex?x^n=x\cdot{x}\cdot{x}\cdot...=\prod_{i=1}^{n}x\\ "Степень")    
Остальные процедуры можно легко реализовать через Класс java.lang.Math в Java.

#### Куда положить функции
Вы наверное уже поместили эти функции в класс Main и нарекли их статическими. А теперь уберите их оттуда и положите в отдельный класс. Потому-то задача математических вычислений должна выполняться не основной программой, а модулем/классом нашей программы. Это что-то вроде правила этикета: раскладывать функции в свои классы. От того что вы переместите их в отдельный класс абсолютно ничего не изменится - программа будет ровно так же выполнятся, как и до этого, но теперь строка будет выглядеть намного адекватнее и будет больше напоминать связанное предложение.  
Сравните сами: `Main.sin()` - `Программа считает синус` и что это, простите за программа, самым верхним действием (метадействием) которой является посчитать синус? `Mathematics.sin()` - `Модуль математики считает синус`. Теперь всё логично: программа обращается к своему подмодулю для выполнения необходимого действия.

#### static или public
Теперь другой вопрос: а использовать наши функции мы будем в динамическом или статическом контексте? Что бы ответить на этот порос необходимо выяснить, а будет ли зависеть принцип исполнения этой функции от того в каком классе мы её вызовем? Иначе говоря, будут ли чем то отличаться контексты вызова? Например, при использовании математических алгоритмов в классе номер 1 мы хотим использовать функционал в режиме повышенной точности чисел, а в некотором другом классе номер 2 нам достаточно округления до сотых. Для такого применения нам необходимо будет объявлять функции в классе в динамическом контексте и в последствии создавать объект класса Mathematics, передавая в конструктор, например, числовое значение требуемой точности.

#### private или public
Теперь давайте выясним приватные должны быть функции или публичные. Здесь всё просто! Приватные функции доступны для использования только в коде самого класса, а публичные можно использовать в любом другом классе.

Для того что бы это был модуль доступен из любой точки программы нам нужно его поместить в класс Mathematics например.
```java
Mathematics myStrictMath = new Mathematics(precissionValue);
myStrictMath.sin(5)
```
Теперь нам доступны все публичные функции класса Mathematics, но плюс ко всему именно этот объект (*myStrictMath*) помнит конкретный, переданный ему, показатель точности вычислений.
А пример статического контекста это просто исполнение функции в виде `Mathematics.cos(3)`

#### Запуск
Теперь осталось описанные алгоритмы проверить на работоспособность. Когда мы разрабатываем некоторый модуль какой-то программы крайне нежелательно проверять его работоспособность, вставляя вызов методов и функций класса куда-либо в программу: в метод **main** например или в любой другой уже существующий класс работающей программы. Потом, нам всё равно придется искать по всей программе тестовые вызовы и убирать их оттуда.  
Для тестирования какого-либо функционала лучше всего использовать тесты.  
Тесты это мини-программы написанные на данном языке. В контексте Java ООП тесты представляют собой void функции в некотором классе, например `MathematicTests`, которые можно запускать либо по-отдельности, либо все вместе (все тесты в классе). В классе один тест-функция должен покрывать один тестируемый метод и полностью проверять его работоспособность. В нашем случаем нам необходимо создать шесть тестов под каждый реализуемый математический функционал.  

Внутри каждого теста мы напишем простую строку, которая проверит факт того что наша функция факториала возвращает правильное, указанное нами значение: `Assertions.assertEquals(6, Mathematics.factorial(3));`. Однако суть тестов заключается в том, что проверяя функцию на работоспособность иы должны так же проверить её устойчивость к исключительным ситуациям. А в случае факториала есть одна исключительная ситуация - это факториал от нуля. Значит наши тесты должны теперь выглядеть следующим образом:
```java
Assertions.assertEquals(1, Mathematics.factorial(0));
Assertions.assertEquals(6, Mathematics.factorial(3));
```


### Доп задача
***А что если попробовать написать функцию факториала и степени в одну строчку?***  
Для этого нам понадобится вспомнить всего лишь две конструкции программирования:
- Рекурсия
- Однострочная сокращенная запись IF

## Этап второй
И так мы написали с вами функции

![экспонента](https://latex.codecogs.com/svg.latex?e^x%20=%20\sum_{n=0}^{N}{\frac{x^n}{n!}}\\)  
![синус](https://latex.codecogs.com/svg.latex?sin(x)=\sum_{n=0}^{N}{(-1)^n\frac{x^{2n+1}}{(2n+1)!}}\\)  
![косинус](https://latex.codecogs.com/svg.latex?\cos(x)=\sum_{n=0}^{N}{\frac{x^{2n}}{(2n)!}}\\)  

